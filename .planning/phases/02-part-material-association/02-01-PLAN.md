---
phase: 02-part-material-association
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/utils/cabinetLogic.ts
  - src/store/cabinetStore.ts
autonomous: true
---

<objective>
Wire part rules to actual materials from the library, enabling per-part material assignment with automatic thickness resolution.

Purpose: Parts need to reference real materials to get accurate thickness values for cut list calculations. Currently, `PartRule.materialId` exists but doesn't fetch the material's thickness from the library.

Output:
- `calculateParts()` resolves material IDs to actual thickness values
- `CutPart` includes resolved `materialId` for each part
- Helper function to get material thickness by ID
- Instance-level material overrides are respected
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-material-system/01-01-SUMMARY.md

# Source files
@src/types/index.ts
@src/utils/cabinetLogic.ts
@src/store/cabinetStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add material resolution to calculateParts</name>
  <files>src/utils/cabinetLogic.ts</files>
  <action>
Modify `calculateParts()` to accept a materials array parameter and resolve `PartRule.materialId` to actual material objects:

1. Add `materials: Material[]` parameter to `calculateParts()` function signature
2. Create helper function `getMaterialThickness(materialId: string | undefined, materials: Material[], fallbackThickness: number): number` that:
   - Returns the material's thickness if found
   - Returns fallbackThickness if materialId is undefined or material not found
3. In the part processing loop, for each `PartRule`:
   - Resolve the material using `getMaterialThickness(rule.materialId, materials, context.material_thickness)`
   - Add `materialId` to the resulting `CutPart`
4. Update expression context to include `part_thickness` variable that reflects the resolved material thickness for the current rule (if applicable)

Import `Material` type at top of file. Keep existing logic intact, just wire in the material resolution.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>calculateParts accepts materials array and resolves materialId to thickness for each part</done>
</task>

<task type="auto">
  <name>Task 2: Support instance-level material overrides</name>
  <files>src/utils/cabinetLogic.ts</files>
  <action>
Extend `calculateParts()` to support instance-level material overrides (from `CabinetInstance.materialOverrides`):

1. Add `materialOverrides?: Record<string, string>` parameter to `calculateParts()`
2. In part processing, check if `materialOverrides[rule.id]` or `materialOverrides[rule.partName]` exists
3. If override exists, use that materialId instead of `rule.materialId`
4. Update `buildExpressionContext()` to add material-related variables from resolved materials:
   - Keep existing pattern.materials?.carcass?.thickness logic
   - Add comment explaining the precedence: instance override > rule materialId > pattern default > global default

This enables per-cabinet customization like using oak for doors but white for carcass.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`</verify>
  <done>materialOverrides parameter supported, override precedence documented in code</done>
</task>

<task type="auto">
  <name>Task 3: Update store and callers to pass materials</name>
  <files>src/store/cabinetStore.ts</files>
  <action>
Update any store functions that call `calculateParts()` to pass the materials array:

1. Search for usages of `calculateParts` in the codebase
2. Update each call site to pass `get().materials` as the materials parameter
3. If `calculateParts` is called from components, those calls will be updated when components use it

Also add a convenience selector hook if not already present:
- `useMaterials()` - returns the materials array (may already exist from Phase 1)

Verify the store already has `getMaterialById(id)` from Phase 1 - this can be used by components.
  </action>
  <verify>TypeScript compiles: `npm run build` or `npx tsc --noEmit`; grep for calculateParts calls to verify all updated</verify>
  <done>All calculateParts call sites pass materials array</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx tsc --noEmit` passes with no type errors
- [ ] `calculateParts()` signature includes materials parameter
- [ ] `CutPart` results include materialId when rule specifies one
- [ ] Material thickness resolution uses library, not hardcoded values
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Parts can be assigned materials from library
- Material thickness is resolved from library, not just pattern/global defaults
</success_criteria>

<output>
After completion, create `.planning/phases/02-part-material-association/02-01-SUMMARY.md`
</output>
